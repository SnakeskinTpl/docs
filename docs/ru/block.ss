- namespace docs.ru.api['1::Директивы']['1::Создание шаблона']['5::block']

/*!
 * snakeskin.github.io
 * https://github.com/SnakeskinTpl/snakeskin.github.io
 *
 * Released under the MIT license
 * https://github.com/SnakeskinTpl/snakeskin.github.io/blob/master/LICENSE
 */

- include '../../tpls/modules/base'

{template main[%fileName%]() extends base.main}
#{block root}

Директива декларирует статичный блок или подшаблон c заданным именем и входными параметрами.

## Паспорт

| Декларация      | Короткий синтаксис | Тип директивы                       | Интерполяция |
|-----------------|--------------------|-------------------------------------|--------------|
| Без ограничений | Отсутствует        | Блочная, логическая, функциональная | Не требуется |

## Описание

Директива *block* несёт двойную функциональность: с одной стороны она позволяет создавать [статичные блоки](#guide.html#inheritBasic),
а с другой - вызываемые. Блоки являются фундаментальной ячейкой Snakeskin, т.к. играют ключевую роль при наследовании,
но если статичный блок - это просто выделение фрагмента текста, чтобы в дальнейшем иметь возможность его переопределить
в дочернем шаблоне, то вызываемый блок - это по сути вложенная функция-шаблон, т.е. после декларации его можно неоднократно вызывать и
передавать различные параметры.

Разница в декларации статичного блока от динамического заключается в наличии скобок для параметров, например:

#{+= self.example()}

```jade-like
- namespace demo
- template index()
	\/// Статичный блок
	- block hello
		Hello world!

	\/// Вызываемый блок
	- block helloWithName(name)
		Hello {name}!
```

```classic
{namespace demo}
{template index()}
	\/// Статичный блок
	{block hello}
		Hello world!
	{/}

	\/// Вызываемый блок
	{block helloWithName(name)}
		Hello {name}!
	{/}
{/template}
```

#{/}

Параметров у блока может быть неограниченное количество,
а т.к. директива *block* является функциональной, то она реализует [стандартный механизм декларации параметров](guide.html#introParams).
По умолчанию вызываемые блоки возвращают строки, однако это поведение можно поменять задав
специальный [renderMode](#compile--renderMode) или явно вернув значение через директиву [return](#return).

Название блока соответствует названию функции в JavaScript, поэтому оно подчиняется тем же правилам, причём статичные блоки
и вызываемые лежат в одном пространстве имён. В рамках шаблона не может быть 2-х блоков с одинаковым названием.

### Блок как метод шаблона

Вызываемые блоки - это методы шаблона, т.е. они наследуются в дочерних шаблонах, могут переопределяться и т.д., а сама
механика наследования практически идентична со статичными блоками и шаблонами, и описана в [отдельной главе](guide.html#inheritBlocks).

При создании вызываемого блока он ставиться как свойство `.Blocks.названиеБлока` исходного шаблона, и, как правило, вызывается
с помощью директивы [call](#call) и указателя [self](#template--Стандартные_переменные_шаблона), например:

#{+= self.example()}

```jade-like
- namespace demo
- template index()
	- block hello(name)
		Hello {name}!

	+= self.hello('kobezzza')
```

```classic
{namespace demo}
{template index()}
	{block hello(name)}
		Hello {name}!
	{/}

	{+= self.hello('kobezzza') /}
{/template}
```

#{/}

**Примечание:** *this* внутри блока ссылается на *this* шаблона.

### Стандартные переменные блока

Каждый вызываемый блок определяет ряд функций, которые можно использовать в нём:

`getTplResult` - функция, которая возвращает результат работы блока, также может принимать один логический входной
параметр, при задании которого после вызова функции результат работы блока будет обнуляться;

`clearTplResult` - функция, которая обнуляет результат работы блока.

### Внешние блоки

Любые блоки могут декларироваться как внутри шаблона или другого блока, так и в глобальной области, но при такой декларации
есть ряд дополнительных правил: блок должен декларироваться **до** шаблона, методом которого он является; блок должен
явно указывать к какому шаблону он принадлежит (для этого используется оператор `->`), например:

#{+= self.example()}

```jade-like
- namespace demo

- block index->hello(name)
	Hello {name}!

- template index()
	+= self.hello('kobezzza')
```

```classic
{namespace demo}

{block index->hello(name)}
	Hello {name}!
{/block}

{template index()}
	{+= self.hello('kobezzza') /}
{/template}
```

#{/}

Такие блоки могут даже находиться в разных файлах и подключаться через [include](#include), но должны обязательно подключаться
до декларации шаблона.

### Самовызываемые блоки

Вызываемый блок можно вызвать немедленно после декларации: для этого используется специальный оператор `=>`, например:

#{+= self.example()}

```jade-like
- namespace demo

- template index()
	- block hello(name) => 'kobezzza'
		Hello {name}!
```

```classic
{namespace demo}

{template index()}
	{block hello(name) => 'kobezzza'}
		Hello {name}!
	{/}
{/template}
```

#{/}

Такой же синтаксис можно использовать и для внешних блоков:

#{+= self.example()}

```jade-like
- namespace demo

- block index->hello(name) => 'kobezzza'
	Hello {name}!

- template index()
```

```classic
{namespace demo}

{block index->hello(name) => 'kobezzza'}
	Hello {name}!
{/block}

{template index()}
{/template}
```

#{/}

### Ссылка `&` для удобного рекурсивного вызова блока

При использовании *call* для вызова блока можно использовать специальный указать `&`, который ссылается на блок внутри
которого он используется - это удобно для организации рекурсий, например:

#{+= self.example()}

```jade-like
- namespace demo

- template index()
	- block iterate(i)
		{i}

		- if i
			+= &(--i)

	+= self.iterate(5)
```

```classic
{namespace demo}

{template index()}
	{block iterate(i)}
		{i}

		{if i}
			{+= &(--i) /}
		{/}
	{/}

	{+= self.iterate(5) /}
{/template}
```

#{/}

#{/block}
{/template}
