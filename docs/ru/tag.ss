- namespace docs.ru.api['Директивы']['Работа с HTML/XML']['3::tag']

/*!
 * snakeskin.github.io
 * https://github.com/SnakeskinTpl/snakeskin.github.io
 *
 * Released under the MIT license
 * https://github.com/SnakeskinTpl/snakeskin.github.io/blob/master/LICENSE
 */

- include '../../tpls/modules/base'

{template main[%fileName%]() extends base.main}
#{block root}

Директива **tag** вставляет код декларации HTML/XML тега по заданным параметрам.

## Паспорт

| Декларация                                | Короткий синтаксис | Тип директивы |
|-------------------------------------------|--------------------|---------------|
| Только внутри шаблонов или внешних блоков | `<`                | Блочная       |

## Описание

Директива *tag* является универсальным инструментом для генерации XML подобных структур.
Общая форма директивы следующая:

```js
tag название директивы
```

Например:

#{+= self.example()}

```jade-like
- tag span
< span
```

```classic
{tag span}{/tag}
{< span}{/}
```

#{/}

### Создание элемента с заданием классов и ИД

Для удобного задания классов и ИД-а в *tag* используется синтаксис селекторов CSS, например:

#{+= self.example()}

```jade-like
< span#baz.foo.bar
\/// Если не указать имя создаваемого тега,
\/// то будет использоваться div
< .bla
```

```classic
{< span#baz.foo.bar}{/}
\/// Если не указать имя создаваемого тега,
\/// то будет использоваться div
{< .bla}{/}
```

#{/}

### Задание произвольных атрибутов

Директива *tag* поддерживает задание атрибутов с помощью [attr](#attr), например:

#{+= self.example()}

```jade-like
< input disabled | value = foo
```

```classic
{< input disabled | value = foo}{/}
```

#{/}

### Ссылки на родительский класс

В Snakeskin существует специальный механизм получения значения родительского класса в дочернем теге, который называется
"липкая ссылка". Принцип работы следующий: если при декларации тега задать имя класса, которое начинается с символа `&`,
то он будет заменён на ближайший родительский класс, который декларировался без этого символа, например:

#{+= self.example()}

```jade-like
< .foo
	< .&__bar
	< .&__bla
```

```classic
{< .foo}
	{< .&__bar}{/}
	{< .&__bla}{/}
{/}
```

#{/}

В результате работы шаблона получится следующий код:

```html
<div class="foo">
	<div class="foo__bar"></div>
	<div class="foo__bla"></div>
</div>
```

При реализации этого механизма используется специальный фильтр [bem](https://github.com/SnakeskinTpl/Snakeskin/blob/master/src/live/filters.js#L453),
который можно перегрузить и добавить дополнительную логику.

#### Ссылка на родительский класс в произвольном атрибуте

Альтернативным способом получения липкой ссылки является вызов внутренней переменной шаблона `$class`, например:

#{+= self.example()}

```jade-like
< .foo value = ${$class}
```

```classic
{< .foo value = ${$class}}{/}
```

#{/}

#### Локальные ссылки

Если поместить декларацию класса в специальную конструкцию `[...]`, то классы заданные внутри такого блока не будут
запоминаться как липкая ссылка, а также плейсхолдер `&` будет ссылаться на ближайший по иерархии вложенности класс слева.

#{+= self.example()}

```jade-like
< .b-button[.g-helper]
	< button.&__elem[.&__focused_true]
```

```classic
{< .b-button[.g-helper]}
	{< button.&__elem[.&_focused_true]}{/}
{/}
```

#{/}

В результате работы шаблона получится следующий код:

```html
<div class="b-button g-helper">
	<button class="b-button__elem b-button__elem_focused_true"></button>
</div>
```

### Тег-плейсходер

Специальный тег `?` существует только на этапе трансляции и не включается в конечный код, например:

#{+= self.example()}

```jade-like
< ?.b-button
	< button.&__elem
```

```classic
{< ?.b-button}
	{< button.&__elem}{/}
{/}
```

#{/}

В результате работы шаблона получится следующий код:

```html
<button class="b-button__elem"></button>
```

### Интерполяция

Директива поддерживает механизм интерполяции значений, т.е. есть возможность пробрасывать вычисляемые значения внутрь декларации и
для этого используется специальный синтаксис `${выражение}`.

#{+= self.example()}

```jade-like
- var name = 'span'
< ${name}
```

```classic
{var name = 'foo' /}
{< ${name}}{/}
```

#{/}

Допускается смешивать интерполяцию с обычной декларацией:

#{+= self.example()}

```jade-like
- var name = 'foo'
< .${name}-bla.bar
```

```classic
{var name = 'foo' /}
{< .${name}-bla.bar}{/}
```

#{/}

Для интерполяции в атрибутах используется механизмы [attr](#attr--Интерполяция).

#### Интерполяция и тег-плейсхолдер

#{+= self.example()}

```jade-like
< ${'?'}.b-button
	< button.&__elem
```

```classic
{< ${'?'}.b-button}
	{< button.&__elem}{/}
{/}
```

#{/}

В результате работы шаблона получится следующий код:

```html
<button class="b-button__elem"></button>
```

### Экранирование

Для экранирования спецсимволов директивы используется символ `\\`, например:

#{+= self.example()}

```jade-like
< .bla foo = bar \\= bla
```

```classic
{< .bla foo = bar \\= bla}{/}
```

#{/}

#{/block}
{/template}
